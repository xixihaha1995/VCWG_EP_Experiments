digraph "clusterquick sort" {
	graph [label="quick sort"]
	1 [label="from psychrometrics import psychrometrics, moist_air_density
import logging
import numpy
import copy
import _0_vcwg_ep_coordination as coordination
\"\"\"
Calculate building characteristics
Developed by Mohsen Moradi and Amir A. Aliabadi
Atmospheric Innovations Research (AIR) Laboratory, University of Guelph, Guelph, Canada
Last update: February 2020
Originally developed by Bruno Bueno
\"\"\"
\"\"\"

    properties
        % Building parameters
        floorHeight         % floor height [m]
        intHeat;            % time step internal heat gains per unit floor area [W m^-2] (bld) (sensible only)
        intHeatNight;       % nighttime internal heat gains per unit floor area [W m^-2] (floor)
        intHeatDay;         % daytime internal heat gains per unit floor area [W m^-2] (floor)
        intHeatFRad;        % radiant fraction of internal gains
        intHeatFLat;        % latent fraction of internal gains
        infil;              % Infiltration Air Change per Hour (ACH) [hr^-1]
        vent;               % Ventilation rate per unit floor area [m^3 s^-1 m^-2]
        glazingRatio;       % glazing ratio
        uValue;             % window U-value [W m^-2 K^-1] (including film coeff)
        shgc;               % window Solar Heat Gain Coefficient (SHGC)
        condType;           % cooling condensation system type {'AIR', 'WATER'}
        cop;                % COP of the cooling system (nominal)
        coolSetpointDay;    % daytime indoor cooling set-point [K]
        coolSetpointNight;  % nighttime indoor cooling set-point [K]
        heatSetpointDay;    % daytime indoor heating set-point [K]
        heatSetpointNight;  % nighttime indoor heating set-point [K]
        coolCap;            % rated cooling system capacity [W m^-2]
        heatCap;            % rated heating system capacity [W m^-2]
        heatEff;            % heating system efficiency (-)
        canyon_fraction     # fraction of waste heat released to canyon, default = 1
        mSys;               % HVAC supply mass flowrate [kg s^-1 m^-2]
        indoorTemp;         % indoor air temperature [K]
        indoorHum;          % indoor specific humidity [kgv kga^-1]
        Twb;                % wetbulb temperature [C]
        Tdp;                % dew point [C]
        indoorRhum;         % indoor relative humidity [%]

        area_floor;         % total floor space of the BEM
        FanMax;             % max fan flow rate [m^3 s^-1] per DOE
        nFloor;             % number of floors
        RadFOcc;            % Radiant fraction of occupant
        LatFOcc;            % Latent fraction of occupant
        RadFEquip;          % Radiant fraction of equipment
        RadFLight;          % Radiant fraction of light

        Type;               % DOE reference building type
        Era;                % PRE80, PST80, NEW
        Zone;               % Climate zone number

        % Calculated values
        sensCoolDemand;     % building sensible cooling demand per unit building footprint area [W m^-2]
        sensHeatDemand;     % building sensible heating demand per unit building footprint area [W m^-2]
        copAdj;             % adjusted COP per temperature
        dehumDemand;        % Latent heat demand for dehumidification of air per unit building footprint area [W m^-2]
        coolConsump;        % cooling energy consumption per unit building footprint area OR per unit floor area [W m^-2]
        heatConsump;        % heating energy consumption per unit floor area [W m^-2]
        sensWaste;          % sensible waste heat per unit building footprint area [W m^-2]
        latWaste;           % lat waste heat per unit building footprint area [W m^-2]
        fluxMass;           % mass surface heat flux [W m^-2] (mass to indoor air)
        fluxWall;           % wall surface heat flux [W m^-2] (wall to inside)
        fluxRoof;           % roof surface heat flux [W m^-2] (roof to inside)
        fluxSolar;          % solar heat gain per unit floor area [W m^-2] through window (SHGC)
        fluxWindow;         % heat gain/loss from window per unit floor area [W m^-2] (U-value)
        fluxInterior;       % internal heat gain adjusted for latent/LW heat per unit floor area [W m^-2]
        fluxInfil;          % heat flux from infiltration per unit floor area [W m^-2]
        fluxVent;           % heat flux from ventilation per unit floor area [W m^-2]
        ElecTotal;          % total electricity consumption per unit floor area [W m^-2]
        GasTotal;           % total gas consumption per unit floor area [W m^-2]
        Qhvac;              % total heat removed (sensible + latent) per unit building footprint area [W m^-2] (calculated in cooling system)
        Qheat;              % total heat added (sensible only) per unit building footprint area [W m^-2] (calculated in heating system)
    \"\"\"
TEMPERATURE_COEFFICIENT_CONFLICT_MSG = 'FATAL ERROR!'
def __init__(self, floorHeight, intHeatNight, intHeatDay, intHeatFRad,...
def __repr__(self):...
def is_near_zero(self, val, tol=1e-14):...
def BEMCalc(self, canTemp, canHum, BEM, MeteoData, ParCalculation, simTime,...
"]
	subgraph cluster__init__ {
		graph [label=__init__]
		3 [label="self.floorHeight = float(floorHeight)
self.intHeat = intHeatNight
self.intHeatNight = intHeatNight
self.intHeatDay = intHeatDay
self.intHeatFRad = intHeatFRad
self.intHeatFLat = intHeatFLat
self.infil = infil
self.vent = vent
self.glazingRatio = glazingRatio
self.uValue = uValue
self.shgc = shgc
self.condType = condType
self.cop = cop
self.coolSetpointDay = coolSetpointDay
self.coolSetpointNight = coolSetpointNight
self.heatSetpointDay = heatSetpointDay
self.heatSetpointNight = heatSetpointNight
self.coolCap = coolCap
self.heatEff = heatEff
self.mSys = coolCap / 1004.0 / (min(coolSetpointDay, coolSetpointNight) - 
    14 - 273.15)
self.indoorTemp = initialTemp
self.indoorHum = 0.006
self.heatCap = 999
self.copAdj = cop
self.canyon_fraction = 1.0
self.sensWaste = 0
self.Type = 'null'
self.Era = 'null'
self.Zone = 'null'
self.logger = logging.getLogger(__name__)
"]
		"3_calls" [label="float
min
logging.getLogger" shape=box]
		3 -> "3_calls" [label=calls style=dashed]
	}
	subgraph cluster__repr__ {
		graph [label=__repr__]
		6 [label="return 'BuildingType: {a}, Era: {b}, Zone: {c}'.format(a=self.Type, b=self.
    Era, c=self.Zone)
"]
	}
	subgraph clusteris_near_zero {
		graph [label=is_near_zero]
		10 [label="return abs(float(val)) < tol
"]
	}
	subgraph clusterBEMCalc {
		graph [label=BEMCalc]
		14 [label="\"\"\"
        ------
        INPUT:
        canTemp: Average canyon temperature [K]
        canHum: Average canyon specific humidity [kg kg^-1]
        BEM: Building energy parameters
        MeteoData: Forcing variables
        ParCalculation: General calculation parameters
        simTime: Simulation time parameters
        Geometry_m: Geometric parameters
        FractionsRoof:
        SWR: Shortwave radiation fluxes [W m^-2]
        -------
        OUTPUT:
        sensCoolDemand: building sensible cooling demand per unit building footprint area [W m^-2]
        sensHeatDemand: building sensible heating demand per unit building footprint area [W m^-2]
        copAdj: adjusted COP per temperature
        dehumDemand: Latent heat demand for dehumidification of air per unit building footprint area [W m^-2]
        coolConsump: cooling energy consumption per unit building footprint area OR per unit floor area [W m^-2]
        heatConsump: heating energy consumption per unit floor area [W m^-2]
        sensWaste: sensible waste heat per unit building footprint area [W m^-2]
        sensWasteCoolHeatDehum: Sensible waste heat per unit building footprint area only including cool, heat, and dehum [W m-2]
        latWaste: lat waste heat per unit building footprint area [W m^-2]
        fluxMass: mass surface heat flux [W m^-2] (mass to indoor air)
        fluxWall: wall surface heat flux [W m^-2] (wall to inside)
        fluxRoof: roof surface heat flux [W m^-2] (roof to inside)
        fluxSolar: solar heat gain per unit floor area [W m^-2] through window (SHGC)
        fluxWindow: heat gain/loss from window per unit floor area [W m^-2] (U-value)
        fluxInterior: internal heat gain adjusted for latent/LW heat per unit floor area [W m^-2]
        fluxInfil: heat flux from infiltration per unit floor area [W m^-2]
        fluxVent: heat flux from ventilation per unit floor area [W m^-2]
        ElecTotal: total electricity consumption per unit floor area [W m^-2]
        GasTotal: total gas consumption per unit floor area [W m^-2]
        Qhvac: total heat removed (sensible + latent) per unit building footprint area [W m^-2] (calculated in cooling system)
        Qheat: total heat added (sensible only) per unit building footprint area [W m^-2] (calculated in heating system)
        nFloor: Number of floors
        indoorTemp: Indoor air temperature [K]
        indoorHum: Indoor specific humidity [kg kg^-1]
        QWindowSolar: Solar Heat Gain on windows per building footprint area [W m^-2]
        QWall: Wall load per unit building footprint area [W m^-2]
        QMass: Other surfaces load per unit building footprint area [W m^-2]
        QWindow: window load due to temperature difference per unit building footprint area [W m^-2]
        QCeil: ceiling load per unit building footprint area [W m^-2]
        QInfil: infiltration load per unit building footprint area [W m^-2]
        QVen: ventilation load per unit building footprint area [W m^-2]
        QWater: energy consumption for domestic hot water [W m^-2]
        QGas: energy consumption for gas [W m^-2]
        \"\"\"
self.logger.debug('Logging at {} {}'.format(__name__, self.__repr__()))
self.ElecTotal = 0.0
self.nFloor = max(Geometry_m.Height_canyon / float(self.floorHeight), 1)
self.Qheat = 0.0
self.sensCoolDemand = 0.0
self.sensHeatDemand = 0.0
self.sensWaterHeatDemand = 0.0
self.coolConsump = 0.0
self.heatConsump = 0.0
self.sensWaste = 0.0
self.sensWasteCoolHeatDehum = 0.0
self.dehumDemand = 0.0
self.Qhvac = 0.0
self.elecDomesticDemand = 0.0
Qdehum = 0.0
dens = moist_air_density(MeteoData.Pre, self.indoorTemp, self.indoorHum)
evapEff = 1.0
volVent = self.vent * self.nFloor
volInfil = self.infil * Geometry_m.Height_canyon / 3600.0
T_wall = (BEM.wallSun.Tint + BEM.wallShade.Tint) / 2
massFlorRateSWH = BEM.SWH * self.nFloor / 3600.0
T_ceil = (FractionsRoof.fimp * BEM.roofImp.Tint + FractionsRoof.fveg * BEM.
    roofVeg.Tint)
T_mass = BEM.mass.Text
T_indoor = self.indoorTemp
T_can = canTemp
facArea = 2 * Geometry_m.Height_canyon / numpy.sqrt(Geometry_m.Width_roof *
    Geometry_m.Width_roof)
wallArea = facArea * (1.0 - self.glazingRatio)
winArea = facArea * self.glazingRatio
massArea = 2 * self.nFloor - 1
ceilingArea = 1
isEqualNightStart = self.is_near_zero(simTime.secDay / 3600.0 -
    ParCalculation.nightStart)
if simTime.secDay / 3600.0 < ParCalculation.nightEnd or (simTime.secDay / 
"]
		"14_calls" [label="self.logger.debug
max
moist_air_density
numpy.sqrt
self.is_near_zero" shape=box]
		14 -> "14_calls" [label=calls style=dashed]
		15 [label="self.logger.debug('{} Night set points @{}'.format(__name__, simTime.secDay /
    3600.0))
T_cool = self.coolSetpointNight
T_heat = self.heatSetpointNight
self.intHeat = self.intHeatNight * self.nFloor
"]
		"15_calls" [label="self.logger.debug" shape=box]
		15 -> "15_calls" [label=calls style=dashed]
		16 [label="zac_in_wall = 3.076
zac_in_mass = 0.948
zac_in_ceil = 0.948
\"\"\"
        # If ceiling temperature is greater than indoor temperature use a different convective heat transfer coefficient
        if T_ceil > T_indoor:
            zac_in_ceil  = 0.948
        # If ceiling temperature is less than indoor temperature use a different convective heat transfer coefficient
        elif (T_ceil < T_indoor) or self.is_near_zero(T_ceil-T_indoor):
            zac_in_ceil  = 4.040
        else:
            print T_ceil, T_indoor
            raise Exception(self.TEMPERATURE_COEFFICIENT_CONFLICT_MSG)
            return
        \"\"\"
SWRinWall = (SWR.SWRin.SWRinWallSun + SWR.SWRin.SWRinWallShade) / 2
self.QWindowSolar = SWRinWall * self.shgc * winArea
QLinfil = volInfil * dens * ParCalculation.Lv * (canHum - self.indoorHum)
QLvent = volVent * dens * ParCalculation.Lv * (canHum - self.indoorHum)
QLintload = self.intHeat * self.intHeatFLat
self.QWall = wallArea * zac_in_wall * (T_wall - T_cool)
self.QMass = massArea * zac_in_mass * (T_mass - T_cool)
self.QWindow = winArea * self.uValue * (T_can - T_cool)
self.QCeil = ceilingArea * zac_in_ceil * (T_ceil - T_cool)
self.QInfil = volInfil * dens * ParCalculation.cp_atm * (T_can - T_cool)
self.QVen = volVent * dens * ParCalculation.cp_atm * (T_can - T_cool)
self.sensCoolDemand = max(self.QWall + self.QMass + self.QWindow + self.
    QCeil + self.intHeat + self.QInfil + self.QVen + self.QWindowSolar, 0.0)
self.sensHeatDemand = max(-(wallArea * zac_in_wall * (T_wall - T_heat) + 
    massArea * zac_in_mass * (T_mass - T_heat) + winArea * self.uValue * (
    T_can - T_heat) + zac_in_ceil * (T_ceil - T_heat) + self.intHeat + 
    volInfil * dens * ParCalculation.cp_atm * (T_can - T_heat) + volVent *
    dens * ParCalculation.cp_atm * (T_can - T_heat) + self.QWindowSolar), 0.0)
if self.sensCoolDemand > 0.0 and canTemp > 288.0:
"]
		"16_calls" [label="max
max" shape=box]
		16 -> "16_calls" [label=calls style=dashed]
		18 [label="\"\"\"
            # Energy is used to dehumidify volumetric flow rate of air per unit building footprint area that flows through dehumidifier,
            # Calculate an arbitrary Volumetric Flow rate based on sensible Cooling demand
            # Assume air is cooled to 10C and fraction f = 0.02 is dehumidified
            # equal to f * sensCoolDemand / (dens * Cp * (T_indoor - (273.15+10)))
            # Fraction of volumetric flow rate of air to cool per unit building footprint area [m^3 s^-1 m^-2]
            # VolDehum = 0.02 * self.sensCoolDemand / (dens*ParCalculation.cp_atm*(T_indoor - (273.15+10)))
            # Energy is used to dehumidify this volumetric flow rate of air per unit building footprint area,
            # Assume air is cooled to 10C and conditioned to 70% RH (5.5 [gv kg^-1])
            # This energy is equal to VolDehum * dens * (self.indoorHum - 0.0055)*ParCalculation.Lv
            # Latent heat demand for dehumidification of air per unit building footprint area [W m^-2]
            # self.dehumDemand = max(VolDehum * dens * (self.indoorHum - 0.0055)*ParCalculation.Lv, 0.)
            \"\"\"
self.dehumDemand = 0.1 * self.sensCoolDemand
Qdehum = copy.copy(self.dehumDemand)
if self.dehumDemand + self.sensCoolDemand > self.coolCap * self.nFloor:
"]
		"18_calls" [label="copy.copy" shape=box]
		18 -> "18_calls" [label=calls style=dashed]
		23 [label="self.Qhvac = self.coolCap * self.nFloor
PLR = self.coolCap * self.nFloor / (self.dehumDemand + self.sensCoolDemand)
self.sensCoolDemand = self.sensCoolDemand * PLR
self.dehumDemand = self.dehumDemand * PLR
"]
		24 [label="self.coolConsump = max(self.sensCoolDemand + self.dehumDemand, 0.0
    ) / self.copAdj
if self.condType == 'AIR':
"]
		"24_calls" [label=max shape=box]
		24 -> "24_calls" [label=calls style=dashed]
		26 [label="self.sensWasteCoolHeatDehum = max(self.sensCoolDemand + self.dehumDemand, 0
    ) + self.coolConsump
self.latWaste = 0.0
"]
		"26_calls" [label=max shape=box]
		26 -> "26_calls" [label=calls style=dashed]
		27 [label="self.sensHeatDemand = 0.0
"]
		19 [label="Q = self.intHeat + self.QWindowSolar + self.Qheat - self.sensCoolDemand
H1 = (T_wall * wallArea * zac_in_wall + T_mass * massArea * zac_in_mass + 
    T_ceil * zac_in_ceil + T_can * winArea * self.uValue + T_can * volInfil *
    dens * ParCalculation.cp_atm + T_can * volVent * dens * ParCalculation.
    cp_atm)
H2 = (wallArea * zac_in_wall + massArea * zac_in_mass + zac_in_ceil + 
    winArea * self.uValue + volInfil * dens * ParCalculation.cp_atm + 
    volVent * dens * ParCalculation.cp_atm)
self.indoorTemp = (H1 + Q) / H2
self.indoorHum = self.indoorHum + simTime.dt / (dens * ParCalculation.Lv *
    Geometry_m.Height_canyon) * (QLintload + QLinfil + QLvent - Qdehum)
_Tdb, _w, _phi, _h, _Tdp, _v = psychrometrics(self.indoorTemp, self.
    indoorHum, MeteoData.Pre)
self.indoorRhum = _phi
self.fluxWall = zac_in_wall * (T_indoor - T_wall)
self.fluxRoof = zac_in_ceil * (T_indoor - T_ceil)
self.fluxMass = zac_in_mass * (T_indoor - T_mass
    ) + self.intHeat * self.intHeatFRad / massArea
self.fluxSolar = self.QWindowSolar / self.nFloor
self.fluxWindow = winArea * self.uValue * (T_can - T_indoor) / self.nFloor
self.fluxInterior = self.intHeat * self.intHeatFRad * (1.0 - self.intHeatFLat
    ) / self.nFloor
self.fluxInfil = volInfil * dens * ParCalculation.cp_atm * (T_can - T_indoor
    ) / self.nFloor
self.fluxVent = volVent * dens * ParCalculation.cp_atm * (T_can - T_indoor
    ) / self.nFloor
self.ElecTotal = self.coolConsump / self.nFloor + BEM.Elec + BEM.Light
self.elecDomesticDemand = self.nFloor * (BEM.Elec + BEM.Light)
CpH20 = 4200.0
T_hot = 49 + 273.15
self.sensWaterHeatDemand = massFlorRateSWH * CpH20 * (T_hot - MeteoData.
    waterTemp)
self.sensWaterHeatDemand = massFlorRateSWH * CpH20 * (T_hot - MeteoData.
    waterTemp)
self.QWater = (1 / self.heatEff - 1.0) * self.sensWaterHeatDemand
self.QGas = BEM.Gas * (1 - self.heatEff) * self.nFloor
self.sensWaste = self.sensWasteCoolHeatDehum + self.QWater + self.QGas
\"\"\"
        Lichen: sync EP and VCWG
        1. VCWG will be acquiring (waiting) until EP release the lock
            a. If VCWG has acquired the lock, it means moments ago, 
                EP has released the lock(coordiantion.sem_energyplus.release()).
                It also means the accumulated_waste_hvac for vcwg_needed_time_index_in_seconds has been updated.
        2. VCWG will update the next vcwg_needed_time_index_in_seconds.
        3. self.sensWaste <- coordination.ep_accumulated_waste_heat*10
        4. VCWG will reset coordination.ep_accumulated_waste_heat to 0
        4. coordination.ep_oat <- canTemp - 273.15
        \"\"\"
coordination.sem_energyplus.acquire()
vcwg_time_index_in_seconds = (simTime.day - 1) * 3600 * 24 + simTime.secDay
print(
    f'VCWG: Update needed time index[accumulated seconds]: {vcwg_time_index_in_seconds}\n'
    )
coordination.vcwg_needed_time_idx_in_seconds = vcwg_time_index_in_seconds
if coordination.ep_accumulated_waste_heat < 1e-30:
"]
		"19_calls" [label="psychrometrics
coordination.sem_energyplus.acquire
print" shape=box]
		19 -> "19_calls" [label=calls style=dashed]
		31 [label="self.sensWaste = 20
"]
		32 [label="coordination.ep_accumulated_waste_heat = 0
coordination.ep_oat = canTemp - 273.15
coordination.sem_vcwg.release()
self.GasTotal = BEM.Gas + massFlorRateSWH * CpH20 * (T_hot - MeteoData.
    waterTemp) / self.nFloor / self.heatEff + self.heatConsump / self.nFloor
"]
		"32_calls" [label="coordination.sem_vcwg.release" shape=box]
		32 -> "32_calls" [label=calls style=dashed]
		31 -> 32 [label=""]
		19 -> 31 [label="coordination.ep_accumulated_waste_heat < 1e-30"]
		33 [label="self.sensWaste = coordination.ep_accumulated_waste_heat * 0.0001
"]
		33 -> 32 [label=""]
		19 -> 33 [label="(coordination.ep_accumulated_waste_heat >= 1e-30)"]
		27 -> 19 [label=""]
		26 -> 27 [label=""]
		24 -> 26 [label="self.condType == 'AIR'"]
		28 [label="if self.condType == 'WAT':
"]
		29 [label="self.sensWasteCoolHeatDehum = max(self.sensCoolDemand + self.dehumDemand, 0
    ) + self.coolConsump * (1.0 - evapEff)
self.latWaste = max(self.sensCoolDemand + self.dehumDemand, 0
    ) + self.coolConsump * evapEff
"]
		"29_calls" [label="max
max" shape=box]
		29 -> "29_calls" [label=calls style=dashed]
		29 -> 27 [label=""]
		28 -> 29 [label="self.condType == 'WAT'"]
		28 -> 27 [label="(self.condType != 'WAT')"]
		24 -> 28 [label="(self.condType != 'AIR')"]
		23 -> 24 [label=""]
		18 -> 23 [label="self.dehumDemand + self.sensCoolDemand > self.coolCap * self.nFloor"]
		25 [label="self.Qhvac = self.dehumDemand + self.sensCoolDemand
"]
		25 -> 24 [label=""]
		18 -> 25 [label="(self.dehumDemand + self.sensCoolDemand <= self.coolCap * self.nFloor)"]
		16 -> 18 [label="self.sensCoolDemand > 0.0 and canTemp > 288.0"]
		20 [label="if self.sensHeatDemand > 0.0 and canTemp < 288.0:
"]
		21 [label="self.Qheat = min(self.sensHeatDemand, self.heatCap * self.nFloor)
self.heatConsump = self.Qheat / self.heatEff
self.sensWasteCoolHeatDehum = self.heatConsump - self.Qheat
Qdehum = 0.0
self.sensCoolDemand = 0.0
"]
		"21_calls" [label=min shape=box]
		21 -> "21_calls" [label=calls style=dashed]
		21 -> 19 [label=""]
		20 -> 21 [label="self.sensHeatDemand > 0.0 and canTemp < 288.0"]
		20 -> 19 [label="(not (self.sensHeatDemand > 0.0 and canTemp < 288.0))"]
		16 -> 20 [label="(not (self.sensCoolDemand > 0.0 and canTemp > 288.0))"]
		15 -> 16 [label=""]
		14 -> 15 [label="simTime.secDay / 3600.0 < ParCalculation.nightEnd or (simTime.secDay / 
    3600.0 > ParCalculation.nightStart or isEqualNightStart)"]
		17 [label="self.logger.debug('{} Day set points @{}'.format(__name__, simTime.secDay /
    3600.0))
T_cool = self.coolSetpointDay
T_heat = self.heatSetpointDay
self.intHeat = self.intHeatDay * self.nFloor
"]
		"17_calls" [label="self.logger.debug" shape=box]
		17 -> "17_calls" [label=calls style=dashed]
		17 -> 16 [label=""]
		14 -> 17 [label="(not (simTime.secDay / 3600.0 < ParCalculation.nightEnd or (simTime.secDay /
    3600.0 > ParCalculation.nightStart or isEqualNightStart)))"]
	}
}
